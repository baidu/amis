{
    "version": 3,
    "file": "env.js",
    "sourceRoot": "",
    "sources": [
        "/src/env.tsx"
    ],
    "names": [],
    "mappings": ";;;;AAAA;;GAEG;AACH,6DAA0B;AAI1B,iGAA0D;AAsE7C,QAAA,UAAU,GAAG,eAAK,CAAC,aAAa,CAAqB,SAAS,CAAC,CAAC;AAM7E,SAAgB,eAAe,CAE7B,iBAAoB;;IAQpB,IAAM,MAAM,GAAG,IAAA,iCAAmB;YAClB,wCAA2B;YAAzC;;YA4BA,CAAC;YArBC,wBAAM,GAAN;gBACE,IAAM,aAAa,GAEf;oBACF,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,OAAO;iBACpC,CAAC;gBAEF,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE;oBACtB,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;iBACvC;gBAED,OAAO,CACL,8BAAC,iBAAiB,4BACX,IAAI,CAAC,KAGR,EACE,aAAa,EACjB,CACH,CAAC;YACJ,CAAC;YACH,cAAC;QAAD,CAAC,AA5BD,CAAc,eAAK,CAAC,SAAS;QACpB,cAAW,GAAG,kBACnB,iBAAiB,CAAC,WAAW,IAAI,iBAAiB,CAAC,IAAI,MACrD;QACG,cAAW,GAAG,kBAAW;QACzB,oBAAiB,GAAG,iBAA4C;aAwBzE,iBAAiB,CAClB,CAAC;IAEF,OAAO,MAEN,CAAC;AACJ,CAAC;AA9CD,0CA8CC",
    "sourcesContent": [
        "/**\n * @file 组件 Env，包括如何发送 ajax，如何通知，如何跳转等等。。\n */\nimport React from 'react';\nimport {RendererConfig} from './factory';\nimport {ThemeInstance} from './theme';\nimport {Action, Api, Payload, Schema} from './types';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport {IScopedContext} from './Scoped';\nimport {RendererEvent} from './utils/renderer-event';\n\nimport type {ToastLevel, ToastConf} from './components/Toast';\n\nexport interface RendererEnv {\n  fetcher: (api: Api, data?: any, options?: object) => Promise<Payload>;\n  isCancel: (val: any) => boolean;\n  notify: (type: ToastLevel, msg: any, conf?: ToastConf) => void;\n  jumpTo: (to: string, action?: Action, ctx?: object) => void;\n  alert: (msg: string) => void;\n  confirm: (msg: string, title?: string) => Promise<boolean>;\n  updateLocation: (location: any, replace?: boolean) => void;\n\n  /**\n   * 阻止路由跳转，有时候 form 没有保存，但是路由跳转了，导致页面没有更新，\n   * 所以先让用户确认一下。\n   *\n   * 单页模式需要这个，如果非单页模式，不需要处理这个。\n   */\n  blockRouting?: (fn: (targetLocation: any) => void | string) => () => void;\n  isCurrentUrl: (link: string, ctx?: any) => boolean | {params?: object};\n\n  /**\n   * 监控路由变化，如果 jssdk 需要做单页跳转需要实现这个。\n   */\n  watchRouteChange?: (fn: () => void) => () => void;\n  rendererResolver?: (\n    path: string,\n    schema: Schema,\n    props: any\n  ) => null | RendererConfig;\n  copy?: (contents: string, format?: any) => void;\n  getModalContainer?: () => HTMLElement;\n  theme: ThemeInstance;\n  affixOffsetTop: number;\n  affixOffsetBottom: number;\n  richTextToken: string;\n  loadRenderer: (\n    schema: Schema,\n    path: string,\n    reRender: Function\n  ) => Promise<React.ReactType> | React.ReactType | JSX.Element | void;\n  loadChartExtends?: () => void | Promise<void>;\n  useMobileUI?: boolean;\n  /**\n   * 过滤 html 标签，可用来添加 xss 保护逻辑\n   */\n  filterHtml: (input: string) => string;\n  beforeDispatchEvent: (\n    e:\n      | string\n      | React.ClipboardEvent<any>\n      | React.DragEvent<any>\n      | React.ChangeEvent<any>\n      | React.KeyboardEvent<any>\n      | React.TouchEvent<any>\n      | React.WheelEvent<any>\n      | React.AnimationEvent<any>\n      | React.TransitionEvent<any>\n      | React.MouseEvent<any>,\n    context: any,\n    scoped: IScopedContext,\n    data: any,\n    broadcast?: RendererEvent<any>\n  ) => void;\n  [propName: string]: any;\n}\n\nexport const EnvContext = React.createContext<RendererEnv | void>(undefined);\n\nexport interface EnvProps {\n  env: RendererEnv;\n}\n\nexport function withRendererEnv<\n  T extends React.ComponentType<React.ComponentProps<T> & EnvProps>\n>(ComposedComponent: T) {\n  type OuterProps = JSX.LibraryManagedAttributes<\n    T,\n    Omit<React.ComponentProps<T>, keyof EnvProps>\n  > & {\n    env?: RendererEnv;\n  };\n\n  const result = hoistNonReactStatic(\n    class extends React.Component<OuterProps> {\n      static displayName = `WithEnv(${\n        ComposedComponent.displayName || ComposedComponent.name\n      })`;\n      static contextType = EnvContext;\n      static ComposedComponent = ComposedComponent as React.ComponentType<T>;\n\n      render() {\n        const injectedProps: {\n          env: RendererEnv;\n        } = {\n          env: this.props.env || this.context\n        };\n\n        if (!injectedProps.env) {\n          throw new Error('Env 信息获取失败，组件用法不正确');\n        }\n\n        return (\n          <ComposedComponent\n            {...(this.props as JSX.LibraryManagedAttributes<\n              T,\n              React.ComponentProps<T>\n            >)}\n            {...injectedProps}\n          />\n        );\n      }\n    },\n    ComposedComponent\n  );\n\n  return result as typeof result & {\n    ComposedComponent: T;\n  };\n}\n"
    ]
}