{
    "version": 3,
    "file": "SizeAndPositionManager.js",
    "sourceRoot": "",
    "sources": [
        "/src/components/virtual-list/SizeAndPositionManager.ts"
    ],
    "names": [],
    "mappings": "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",
    "sourcesContent": [
        "/* Forked from react-virtualized ðŸ’– */\nimport {ALIGNMENT} from './constants';\n\nexport type ItemSizeGetter = (index: number) => number;\nexport type ItemSize = number | number[] | ItemSizeGetter;\n\nexport interface SizeAndPosition {\n  size: number;\n  offset: number;\n}\n\ninterface SizeAndPositionData {\n  [id: number]: SizeAndPosition;\n}\n\nexport interface Options {\n  itemCount: number;\n  itemSizeGetter: ItemSizeGetter;\n  estimatedItemSize: number;\n}\n\nexport default class SizeAndPositionManager {\n  private itemSizeGetter: ItemSizeGetter;\n  private itemCount: number;\n  private estimatedItemSize: number;\n  private lastMeasuredIndex: number;\n  private itemSizeAndPositionData: SizeAndPositionData;\n\n  constructor({itemCount, itemSizeGetter, estimatedItemSize}: Options) {\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this.itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this.lastMeasuredIndex = -1;\n  }\n\n  updateConfig({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize\n  }: Partial<Options>) {\n    if (itemCount != null) {\n      this.itemCount = itemCount;\n    }\n\n    if (estimatedItemSize != null) {\n      this.estimatedItemSize = estimatedItemSize;\n    }\n\n    if (itemSizeGetter != null) {\n      this.itemSizeGetter = itemSizeGetter;\n    }\n  }\n\n  getLastMeasuredIndex() {\n    return this.lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index: number) {\n    if (index < 0 || index >= this.itemCount) {\n      throw Error(\n        `Requested index ${index} is outside of range 0..${this.itemCount}`\n      );\n    }\n\n    if (index > this.lastMeasuredIndex) {\n      const lastMeasuredSizeAndPosition =\n        this.getSizeAndPositionOfLastMeasuredItem();\n      let offset =\n        lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {\n        const size = this.itemSizeGetter(i);\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this.itemSizeAndPositionData[i] = {\n          offset,\n          size\n        };\n\n        offset += size;\n      }\n\n      this.lastMeasuredIndex = index;\n    }\n\n    return this.itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this.lastMeasuredIndex >= 0\n      ? this.itemSizeAndPositionData[this.lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n   * Total size of all items being measured.\n   * This value will be completedly estimated initially.\n   * As items as measured the estimate will be updated.\n   */\n  getTotalSize(): number {\n    const lastMeasuredSizeAndPosition =\n      this.getSizeAndPositionOfLastMeasuredItem();\n\n    return (\n      lastMeasuredSizeAndPosition.offset +\n      lastMeasuredSizeAndPosition.size +\n      (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize\n    );\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGNMENT.START,\n    containerSize,\n    currentOffset,\n    targetIndex\n  }: {\n    align: ALIGNMENT | undefined;\n    containerSize: number;\n    currentOffset: number;\n    targetIndex: number;\n  }): number {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGNMENT.END:\n        idealOffset = minOffset;\n        break;\n      case ALIGNMENT.CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      case ALIGNMENT.START:\n        idealOffset = maxOffset;\n        break;\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({\n    containerSize,\n    offset,\n    overscanCount\n  }: {\n    containerSize: number;\n    offset: number;\n    overscanCount: number;\n  }): {start?: number; stop?: number} {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    const maxOffset = offset + containerSize;\n    let start = this.findNearestItem(offset);\n\n    if (typeof start === 'undefined') {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    let stop = start;\n\n    while (offset < maxOffset && stop < this.itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\n    }\n\n    return {\n      start,\n      stop\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index: number) {\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  findNearestItem(offset: number) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition =\n      this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this.binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this.exponentialSearch({\n        index: lastMeasuredIndex,\n        offset\n      });\n    }\n  }\n\n  private binarySearch({\n    low,\n    high,\n    offset\n  }: {\n    low: number;\n    high: number;\n    offset: number;\n  }) {\n    let middle = 0;\n    let currentOffset = 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n\n    return 0;\n  }\n\n  private exponentialSearch({index, offset}: {index: number; offset: number}) {\n    let interval = 1;\n\n    while (\n      index < this.itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this.binarySearch({\n      high: Math.min(index, this.itemCount - 1),\n      low: Math.floor(index / 2),\n      offset\n    });\n  }\n}\n"
    ]
}